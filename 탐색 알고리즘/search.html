<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>탐색 알고리즘</title>
  </head>
  <body>
    <script>
      /* 순차 탐색 알고리즘: O(N)의 시간 복잡도를 가짐
       * 원리: 배열의 처음부터 타겟값을 찾을 때까지 순차적으로 탐색하는 방식
       * 사용: 정렬되지 않은 배열에서 사용 가능
       * 실무: 배열의 크기가 작을 때 사용
       */
      function search(arr, target) {
        for (let i = 0; i < arr.length; i++) {
          if (arr[i] === target) {
            return i;
          }
        }
        return -1;
      }

      /* 이진 탐색 알고리즘: O(logN)의 시간 복잡도를 가짐
       * 원리: 배열의 중간값과 타겟값을 비교하여 타겟값이 중간값보다 크면 중간값의 오른쪽을 탐색하고,
         작으면 중간값의 왼쪽을 탐색하는 방식 
       * 사용: 정렬된 배열에서 사용 가능
       * 실무: 배열의 크기가 크고 정렬되어 있을 때 사용
       */
      function binarySearch(arr, target) {
        let left = 0;
        let right = arr.length - 1;
        while (left <= right) {
          let mid = Math.floor((left + right) / 2);
          if (arr[mid] === target) {
            return mid;
          } else if (arr[mid] < target) {
            left = mid + 1;
          } else {
            right = mid - 1;
          }
        }
        return -1;
      }

      /* 재귀적 이진 탐색 알고리즘(분할정복 방식)
      * 이진 탐색 알고리즘과 성능 비교: 재귀적 이진 탐색 알고리즘은 
        함수 호출로 인한 오버헤드가 있어서 성능이 떨어질 수 있음 
      */
      function binarySearch2(arr, target, left, right) {
        if (left > right) {
          return -1;
        }
        let mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) {
          return mid;
        } else if (arr[mid] < target) {
          return binarySearch2(arr, target, mid + 1, right);
        } else {
          return binarySearch2(arr, target, left, mid - 1);
        }
      }
    </script>
  </body>
</html>
